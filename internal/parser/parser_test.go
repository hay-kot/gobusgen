package parser_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/hay-kot/gobusgen/internal/model"
	"github.com/hay-kot/gobusgen/internal/parser"
)

func writeFile(t *testing.T, dir, name, content string) {
	t.Helper()
	if err := os.WriteFile(filepath.Join(dir, name), []byte(content), 0o644); err != nil {
		t.Fatal(err)
	}
}

func TestParse(t *testing.T) {
	tests := []struct {
		name    string
		files   map[string]string
		varName string
		want    model.GenerateInput
		wantErr string
	}{
		{
			name: "single event",
			files: map[string]string{
				"events.go": `package events

type MutationEvent struct{}

var Events = map[string]any{
	"recipe.mutation": MutationEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "recipe.mutation", PayloadType: "MutationEvent"},
				},
			},
		},
		{
			name: "multiple events sorted",
			files: map[string]string{
				"events.go": `package events

type UserEvent struct{}
type OrderEvent struct{}
type AlertEvent struct{}

var Events = map[string]any{
	"user.created":  UserEvent{},
	"order.placed":  OrderEvent{},
	"alert.fired":   AlertEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "alert.fired", PayloadType: "AlertEvent"},
					{Name: "order.placed", PayloadType: "OrderEvent"},
					{Name: "user.created", PayloadType: "UserEvent"},
				},
			},
		},
		{
			name: "no map found",
			files: map[string]string{
				"events.go": `package events

var Something = "hello"
`,
			},
			varName: "Events",
			wantErr: `no map[string]any variable "Events" found`,
		},
		{
			name: "duplicate event names",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
	"foo.bar": FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `duplicate event name "foo.bar"`,
		},
		{
			name: "grouped var block",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var (
	other = 42
	Events = map[string]any{
		"foo.bar": FooEvent{},
	}
)
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "underscore and hyphen in names",
			files: map[string]string{
				"events.go": `package events

type CleanupEvent struct{}
type SyncEvent struct{}

var Events = map[string]any{
	"shopping_list.cleanup": CleanupEvent{},
	"data-sync.complete":    SyncEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "data-sync.complete", PayloadType: "SyncEvent"},
					{Name: "shopping_list.cleanup", PayloadType: "CleanupEvent"},
				},
			},
		},
		{
			name: "skip generated files",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
}
`,
				"eventbus.gen.go": `// Code generated by gobusgen; DO NOT EDIT.
package events

var Events = map[string]any{
	"should.skip": FooEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "skip test files",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
}
`,
				"events_test.go": `package events

var Events = map[string]any{
	"test.event": FooEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "custom variable name",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var MyBus = map[string]any{
	"foo.bar": FooEvent{},
}
`,
			},
			varName: "MyBus",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "MyBus",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "pascal case collision",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"user.created":  FooEvent{},
	"user_created":  FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `produce the same generated symbol "UserCreated"`,
		},
		{
			name: "event name with whitespace",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo bar": FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `event name "foo bar" contains whitespace`,
		},
		{
			name: "multiple map variables same name across files",
			files: map[string]string{
				"events1.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
}
`,
				"events2.go": `package events

type BarEvent struct{}

var Events = map[string]any{
	"bar.baz": BarEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `multiple map[string]any variables named "Events" found`,
		},
		{
			name: "empty events map",
			files: map[string]string{
				"events.go": `package events

var Events = map[string]any{}
`,
			},
			varName: "Events",
			wantErr: `event map contains no event definitions`,
		},
		{
			name: "map value is function call not struct literal",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

func makeFoo() FooEvent { return FooEvent{} }

var Events = map[string]any{
	"foo.bar": makeFoo(),
}
`,
			},
			varName: "Events",
			wantErr: `must be a composite literal`,
		},
		{
			name: "map key is bare constant reference",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

const key = "foo.bar"

var Events = map[string]any{
	key: FooEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "map key is string conversion of typed constant",
			files: map[string]string{
				"events.go": `package events

type EventName string
type FooEvent struct{}

const key EventName = "foo.bar"

var Events = map[string]any{
	string(key): FooEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "mixed literals and constants",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}
type BarEvent struct{}

const fooKey = "foo.bar"

var Events = map[string]any{
	fooKey:      FooEvent{},
	"bar.baz":   BarEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "bar.baz", PayloadType: "BarEvent"},
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "constant defined in separate file",
			files: map[string]string{
				"consts.go": `package events

type EventName string

const RecipeMutation EventName = "recipe.mutation"
`,
				"events.go": `package events

type MutationEvent struct{}

var Events = map[string]any{
	string(RecipeMutation): MutationEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "recipe.mutation", PayloadType: "MutationEvent"},
				},
			},
		},
		{
			name: "unknown constant reference",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	UnknownConst: FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `constant "UnknownConst" not found in package`,
		},
		{
			name: "unknown constant in string conversion",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	string(UnknownConst): FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `constant "UnknownConst" not found in package`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			for name, content := range tt.files {
				writeFile(t, dir, name, content)
			}

			got, err := parser.Parse(dir, tt.varName)

			if tt.wantErr != "" {
				if err == nil {
					t.Fatalf("expected error containing %q, got nil", tt.wantErr)
				}
				if !strings.Contains(err.Error(), tt.wantErr) {
					t.Fatalf("expected error containing %q, got %q", tt.wantErr, err.Error())
				}
				return
			}

			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if got.PackageName != tt.want.PackageName {
				t.Errorf("PackageName = %q, want %q", got.PackageName, tt.want.PackageName)
			}

			if got.VarName != tt.varName {
				t.Errorf("VarName = %q, want %q", got.VarName, tt.varName)
			}

			if len(got.Events) != len(tt.want.Events) {
				t.Fatalf("Events count = %d, want %d", len(got.Events), len(tt.want.Events))
			}

			for i, ev := range got.Events {
				if ev.Name != tt.want.Events[i].Name {
					t.Errorf("Events[%d].Name = %q, want %q", i, ev.Name, tt.want.Events[i].Name)
				}
				if ev.PayloadType != tt.want.Events[i].PayloadType {
					t.Errorf("Events[%d].PayloadType = %q, want %q", i, ev.PayloadType, tt.want.Events[i].PayloadType)
				}
			}
		})
	}
}
