package parser_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/hay-kot/gobusgen/internal/model"
	"github.com/hay-kot/gobusgen/internal/parser"
)

func writeFile(t *testing.T, dir, name, content string) {
	t.Helper()
	if err := os.WriteFile(filepath.Join(dir, name), []byte(content), 0o644); err != nil {
		t.Fatal(err)
	}
}

func TestParse(t *testing.T) {
	tests := []struct {
		name    string
		files   map[string]string
		varName string
		want    model.GenerateInput
		wantErr string
	}{
		{
			name: "single event",
			files: map[string]string{
				"events.go": `package events

type MutationEvent struct{}

var Events = map[string]any{
	"recipe.mutation": MutationEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "recipe.mutation", PayloadType: "MutationEvent"},
				},
			},
		},
		{
			name: "multiple events sorted",
			files: map[string]string{
				"events.go": `package events

type UserEvent struct{}
type OrderEvent struct{}
type AlertEvent struct{}

var Events = map[string]any{
	"user.created":  UserEvent{},
	"order.placed":  OrderEvent{},
	"alert.fired":   AlertEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "alert.fired", PayloadType: "AlertEvent"},
					{Name: "order.placed", PayloadType: "OrderEvent"},
					{Name: "user.created", PayloadType: "UserEvent"},
				},
			},
		},
		{
			name: "no map found",
			files: map[string]string{
				"events.go": `package events

var Something = "hello"
`,
			},
			varName: "Events",
			wantErr: `no map[string]any variable "Events" found`,
		},
		{
			name: "duplicate event names",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
	"foo.bar": FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `duplicate event name "foo.bar"`,
		},
		{
			name: "grouped var block",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var (
	other = 42
	Events = map[string]any{
		"foo.bar": FooEvent{},
	}
)
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "underscore and hyphen in names",
			files: map[string]string{
				"events.go": `package events

type CleanupEvent struct{}
type SyncEvent struct{}

var Events = map[string]any{
	"shopping_list.cleanup": CleanupEvent{},
	"data-sync.complete":    SyncEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "data-sync.complete", PayloadType: "SyncEvent"},
					{Name: "shopping_list.cleanup", PayloadType: "CleanupEvent"},
				},
			},
		},
		{
			name: "skip generated files",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
}
`,
				"eventbus.gen.go": `// Code generated by gobusgen; DO NOT EDIT.
package events

var Events = map[string]any{
	"should.skip": FooEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "skip test files",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo.bar": FooEvent{},
}
`,
				"events_test.go": `package events

var Events = map[string]any{
	"test.event": FooEvent{},
}
`,
			},
			varName: "Events",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "Events",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "custom variable name",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var MyBus = map[string]any{
	"foo.bar": FooEvent{},
}
`,
			},
			varName: "MyBus",
			want: model.GenerateInput{
				PackageName: "events",
				VarName:     "MyBus",
				Events: []model.EventDef{
					{Name: "foo.bar", PayloadType: "FooEvent"},
				},
			},
		},
		{
			name: "pascal case collision",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"user.created":  FooEvent{},
	"user_created":  FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `produce the same generated symbol "UserCreated"`,
		},
		{
			name: "event name with whitespace",
			files: map[string]string{
				"events.go": `package events

type FooEvent struct{}

var Events = map[string]any{
	"foo bar": FooEvent{},
}
`,
			},
			varName: "Events",
			wantErr: `event name "foo bar" contains whitespace`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			for name, content := range tt.files {
				writeFile(t, dir, name, content)
			}

			got, err := parser.Parse(dir, tt.varName)

			if tt.wantErr != "" {
				if err == nil {
					t.Fatalf("expected error containing %q, got nil", tt.wantErr)
				}
				if !contains(err.Error(), tt.wantErr) {
					t.Fatalf("expected error containing %q, got %q", tt.wantErr, err.Error())
				}
				return
			}

			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if got.PackageName != tt.want.PackageName {
				t.Errorf("PackageName = %q, want %q", got.PackageName, tt.want.PackageName)
			}

			if got.VarName != tt.varName {
				t.Errorf("VarName = %q, want %q", got.VarName, tt.varName)
			}

			if len(got.Events) != len(tt.want.Events) {
				t.Fatalf("Events count = %d, want %d", len(got.Events), len(tt.want.Events))
			}

			for i, ev := range got.Events {
				if ev.Name != tt.want.Events[i].Name {
					t.Errorf("Events[%d].Name = %q, want %q", i, ev.Name, tt.want.Events[i].Name)
				}
				if ev.PayloadType != tt.want.Events[i].PayloadType {
					t.Errorf("Events[%d].PayloadType = %q, want %q", i, ev.PayloadType, tt.want.Events[i].PayloadType)
				}
			}
		})
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && searchStr(s, substr)
}

func searchStr(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
