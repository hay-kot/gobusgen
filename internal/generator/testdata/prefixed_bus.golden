// Code generated by gobusgen; DO NOT EDIT.
package commands

import (
	"context"
	"sync"
)

// CommandEvent represents a typed event name.
type CommandEvent string

const (
	CommandEventOrderCreate CommandEvent = "order.create"
	CommandEventOrderCancel CommandEvent = "order.cancel"
)

// CommandBus provides type-safe publish/subscribe for in-process events.
type CommandBus struct {
	mu          sync.RWMutex
	subscribers map[CommandEvent][]any
	ch          chan commandEnvelope
}

type commandEnvelope struct {
	event   CommandEvent
	payload any
}

// NewCommandBus creates a CommandBus with the given channel buffer size.
func NewCommandBus(size int) *CommandBus {
	if size < 1 {
		size = 1
	}

	return &CommandBus{
		subscribers: newCommandBusSubscribersMap(),
		ch:          make(chan commandEnvelope, size),
	}
}

func newCommandBusSubscribersMap() map[CommandEvent][]any {
	return map[CommandEvent][]any{
		CommandEventOrderCreate: {},
		CommandEventOrderCancel: {},
	}
}

// Start begins processing events. It blocks until ctx is cancelled.
func (bus *CommandBus) Start(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case env := <-bus.ch:
			bus.mu.RLock()
			subs := make([]any, len(bus.subscribers[env.event]))
			copy(subs, bus.subscribers[env.event])
			bus.mu.RUnlock()

			for _, sub := range subs {
				if fn, ok := sub.(func(any)); ok {
					fn(env.payload)
				}
			}
		}
	}
}

// PublishOrderCreate publishes a order.create event.
func (bus *CommandBus) PublishOrderCreate(payload CreateOrderCmd) {
	bus.ch <- commandEnvelope{event: CommandEventOrderCreate, payload: payload}
}

// SubscribeOrderCreate registers a handler for order.create events.
func (bus *CommandBus) SubscribeOrderCreate(fn func(CreateOrderCmd)) {
	bus.mu.Lock()
	defer bus.mu.Unlock()

	bus.subscribers[CommandEventOrderCreate] = append(bus.subscribers[CommandEventOrderCreate], func(v any) {
		payload, ok := v.(CreateOrderCmd)
		if !ok {
			return
		}
		fn(payload)
	})
}

// PublishOrderCancel publishes a order.cancel event.
func (bus *CommandBus) PublishOrderCancel(payload CancelOrderCmd) {
	bus.ch <- commandEnvelope{event: CommandEventOrderCancel, payload: payload}
}

// SubscribeOrderCancel registers a handler for order.cancel events.
func (bus *CommandBus) SubscribeOrderCancel(fn func(CancelOrderCmd)) {
	bus.mu.Lock()
	defer bus.mu.Unlock()

	bus.subscribers[CommandEventOrderCancel] = append(bus.subscribers[CommandEventOrderCancel], func(v any) {
		payload, ok := v.(CancelOrderCmd)
		if !ok {
			return
		}
		fn(payload)
	})
}

// Reference the source variable to suppress unused-variable lint.
var _ = Commands
