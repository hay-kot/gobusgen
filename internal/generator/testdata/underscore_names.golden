// Code generated by gobusgen; DO NOT EDIT.
package mybus

import (
	"context"
	"sync"
)

// Event represents a typed event name.
type Event string

const (
	EventDataSyncComplete    Event = "data-sync.complete"
	EventShoppingListCleanup Event = "shopping_list.cleanup"
)

// EventBus provides type-safe publish/subscribe for in-process events.
type EventBus struct {
	mu          sync.RWMutex
	subscribers map[Event][]any
	ch          chan envelope
}

type envelope struct {
	event   Event
	payload any
}

// New creates an EventBus with the given channel buffer size.
func New(size int) *EventBus {
	if size < 1 {
		size = 1
	}

	return &EventBus{
		subscribers: newSubscribersMap(),
		ch:          make(chan envelope, size),
	}
}

func newSubscribersMap() map[Event][]any {
	return map[Event][]any{
		EventDataSyncComplete:    {},
		EventShoppingListCleanup: {},
	}
}

// Start begins processing events. It blocks until ctx is cancelled.
func (bus *EventBus) Start(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case env := <-bus.ch:
			bus.mu.RLock()
			subs := make([]any, len(bus.subscribers[env.event]))
			copy(subs, bus.subscribers[env.event])
			bus.mu.RUnlock()

			for _, sub := range subs {
				if fn, ok := sub.(func(any)); ok {
					fn(env.payload)
				}
			}
		}
	}
}

// PublishDataSyncComplete publishes a data-sync.complete event.
func (bus *EventBus) PublishDataSyncComplete(payload SyncEvent) {
	bus.ch <- envelope{event: EventDataSyncComplete, payload: payload}
}

// SubscribeDataSyncComplete registers a handler for data-sync.complete events.
func (bus *EventBus) SubscribeDataSyncComplete(fn func(SyncEvent)) {
	bus.mu.Lock()
	defer bus.mu.Unlock()

	bus.subscribers[EventDataSyncComplete] = append(bus.subscribers[EventDataSyncComplete], func(v any) {
		payload, ok := v.(SyncEvent)
		if !ok {
			return
		}
		fn(payload)
	})
}

// PublishShoppingListCleanup publishes a shopping_list.cleanup event.
func (bus *EventBus) PublishShoppingListCleanup(payload CleanupEvent) {
	bus.ch <- envelope{event: EventShoppingListCleanup, payload: payload}
}

// SubscribeShoppingListCleanup registers a handler for shopping_list.cleanup events.
func (bus *EventBus) SubscribeShoppingListCleanup(fn func(CleanupEvent)) {
	bus.mu.Lock()
	defer bus.mu.Unlock()

	bus.subscribers[EventShoppingListCleanup] = append(bus.subscribers[EventShoppingListCleanup], func(v any) {
		payload, ok := v.(CleanupEvent)
		if !ok {
			return
		}
		fn(payload)
	})
}

// Reference the source variable to suppress unused-variable lint.
var _ = MyBus
