package generator

import (
	"strings"
	"text/template"
	"unicode"
)

var tmpl = template.Must(template.New("eventbus").Funcs(template.FuncMap{
	"pascalCase": PascalCase,
}).Parse(eventBusTemplate))

// PascalCase converts a dotted/underscored/hyphenated name to PascalCase.
// e.g. "recipe.mutation" -> "RecipeMutation"
// e.g. "shopping_list.cleanup" -> "ShoppingListCleanup"
// e.g. "data-sync.complete" -> "DataSyncComplete"
func PascalCase(s string) string {
	var b strings.Builder
	upper := true

	for _, r := range s {
		switch {
		case r == '.' || r == '_' || r == '-':
			upper = true
		case upper:
			b.WriteRune(unicode.ToUpper(r))
			upper = false
		default:
			b.WriteRune(r)
		}
	}

	return b.String()
}

const eventBusTemplate = `// Code generated by gobusgen; DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"sync"
)

// Event represents a typed event name.
type Event string

const (
{{- range .Events }}
	Event{{ pascalCase .Name }} Event = "{{ .Name }}"
{{- end }}
)

// EventBus provides type-safe publish/subscribe for in-process events.
type EventBus struct {
	mu          sync.RWMutex
	subscribers map[Event][]any
	ch          chan envelope
}

type envelope struct {
	event   Event
	payload any
}

// New creates an EventBus with the given channel buffer size.
func New(size int) *EventBus {
	return &EventBus{
		subscribers: newSubscribersMap(),
		ch:          make(chan envelope, size),
	}
}

func newSubscribersMap() map[Event][]any {
	return map[Event][]any{
{{- range .Events }}
		Event{{ pascalCase .Name }}: {},
{{- end }}
	}
}

// Start begins processing events. It blocks until ctx is cancelled.
func (bus *EventBus) Start(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case env := <-bus.ch:
			bus.mu.RLock()
			subs := make([]any, len(bus.subscribers[env.event]))
			copy(subs, bus.subscribers[env.event])
			bus.mu.RUnlock()

			for _, sub := range subs {
				if fn, ok := sub.(func(any)); ok {
					fn(env.payload)
				}
			}
		}
	}
}

{{ range .Events }}
// Publish{{ pascalCase .Name }} publishes a {{ .Name }} event.
func (bus *EventBus) Publish{{ pascalCase .Name }}(payload {{ .PayloadType }}) {
	bus.ch <- envelope{event: Event{{ pascalCase .Name }}, payload: payload}
}

// Subscribe{{ pascalCase .Name }} registers a handler for {{ .Name }} events.
func (bus *EventBus) Subscribe{{ pascalCase .Name }}(fn func({{ .PayloadType }})) {
	bus.mu.Lock()
	defer bus.mu.Unlock()

	bus.subscribers[Event{{ pascalCase .Name }}] = append(bus.subscribers[Event{{ pascalCase .Name }}], func(v any) {
		fn(v.({{ .PayloadType }}))
	})
}
{{ end }}
// Reference the source variable to suppress unused-variable lint.
var _ = {{ .VarName }}
`
