package generator

import (
	"strings"
	"text/template"

	"github.com/hay-kot/gobusgen/internal/model"
)

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func article(s string) string {
	if s != "" {
		switch s[0] {
		case 'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u':
			return "an"
		}
	}
	return "a"
}

var tmpl = template.Must(template.New("eventbus").Funcs(template.FuncMap{
	"pascalCase": model.PascalCase,
	"lowerFirst": lowerFirst,
	"article":    article,
}).Parse(eventBusTemplate))

const eventBusTemplate = `// Code generated by gobusgen; DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"sync"
)
{{- $p := .Prefix -}}
{{- $eventType := "Event" -}}{{- if $p -}}{{- $eventType = printf "%sEvent" $p -}}{{- end -}}
{{- $busType := "EventBus" -}}{{- if $p -}}{{- $busType = printf "%sBus" $p -}}{{- end -}}
{{- $ctor := "New" -}}{{- if $p -}}{{- $ctor = printf "New%sBus" $p -}}{{- end -}}
{{- $env := "envelope" -}}{{- if $p -}}{{- $env = printf "%sEnvelope" (lowerFirst $p) -}}{{- end -}}
{{- $subsMap := "newSubscribersMap" -}}{{- if $p -}}{{- $subsMap = printf "new%sBusSubscribersMap" $p -}}{{- end }}

// {{ $eventType }} represents a typed event name.
type {{ $eventType }} string

const (
{{- range .Events }}
	{{ $pc := pascalCase .Name -}}
	{{ $eventType }}{{ $pc }} {{ $eventType }} = "{{ .Name }}"
{{- end }}
)

// {{ $busType }} provides type-safe publish/subscribe for in-process events.
type {{ $busType }} struct {
	mu          sync.RWMutex
	subscribers map[{{ $eventType }}][]any
	ch          chan {{ $env }}

	hookMu      sync.RWMutex
	onPublish   []func({{ $eventType }}, any)
	onDrop      []func({{ $eventType }}, any)
	onSubscribe []func({{ $eventType }})
	onPanic     []func({{ $eventType }}, any, any)
}

type {{ $env }} struct {
	event   {{ $eventType }}
	payload any
}

// {{ $ctor }} creates {{ article $busType }} {{ $busType }} with the given channel buffer size.
func {{ $ctor }}(size int) *{{ $busType }} {
	if size < 1 {
		size = 1
	}

	return &{{ $busType }}{
		subscribers: {{ $subsMap }}(),
		ch:          make(chan {{ $env }}, size),
	}
}

func {{ $subsMap }}() map[{{ $eventType }}][]any {
	return map[{{ $eventType }}][]any{
{{- range .Events }}
	{{ $pc := pascalCase .Name -}}
		{{ $eventType }}{{ $pc }}: {},
{{- end }}
	}
}

// Start begins processing events. It blocks until ctx is cancelled.
func (bus *{{ $busType }}) Start(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case env := <-bus.ch:
			bus.mu.RLock()
			subs := make([]any, len(bus.subscribers[env.event]))
			copy(subs, bus.subscribers[env.event])
			bus.mu.RUnlock()

			for _, sub := range subs {
				func() {
					defer func() {
						if r := recover(); r != nil {
							bus.runOnPanic(env.event, env.payload, r)
						}
					}()
					if fn, ok := sub.(func(any)); ok {
						fn(env.payload)
					}
				}()
			}
		}
	}
}

{{ range .Events }}
{{ $pc := pascalCase .Name -}}
// Publish{{ $pc }} publishes a {{ .Name }} event.
func (bus *{{ $busType }}) Publish{{ $pc }}(payload {{ .PayloadType }}) {
	select {
	case bus.ch <- {{ $env }}{event: {{ $eventType }}{{ $pc }}, payload: payload}:
		bus.runOnPublish({{ $eventType }}{{ $pc }}, payload)
	default:
		bus.runOnDrop({{ $eventType }}{{ $pc }}, payload)
	}
}

// Subscribe{{ $pc }} registers a handler for {{ .Name }} events.
func (bus *{{ $busType }}) Subscribe{{ $pc }}(fn func({{ .PayloadType }})) {
	bus.mu.Lock()
	bus.subscribers[{{ $eventType }}{{ $pc }}] = append(bus.subscribers[{{ $eventType }}{{ $pc }}], func(v any) {
		payload, ok := v.({{ .PayloadType }})
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe({{ $eventType }}{{ $pc }})
}
{{ end }}
// OnPublish registers a hook that fires after an event is successfully enqueued.
func (bus *{{ $busType }}) OnPublish(fn func({{ $eventType }}, any)) {
	bus.hookMu.Lock()
	bus.onPublish = append(bus.onPublish, fn)
	bus.hookMu.Unlock()
}

// OnDrop registers a hook that fires when an event is dropped due to a full buffer.
func (bus *{{ $busType }}) OnDrop(fn func({{ $eventType }}, any)) {
	bus.hookMu.Lock()
	bus.onDrop = append(bus.onDrop, fn)
	bus.hookMu.Unlock()
}

// OnSubscribe registers a hook that fires after a subscriber is registered.
func (bus *{{ $busType }}) OnSubscribe(fn func({{ $eventType }})) {
	bus.hookMu.Lock()
	bus.onSubscribe = append(bus.onSubscribe, fn)
	bus.hookMu.Unlock()
}

// OnPanic registers a hook that fires when a subscriber panics.
func (bus *{{ $busType }}) OnPanic(fn func({{ $eventType }}, any, any)) {
	bus.hookMu.Lock()
	bus.onPanic = append(bus.onPanic, fn)
	bus.hookMu.Unlock()
}

func (bus *{{ $busType }}) runOnPublish(event {{ $eventType }}, payload any) {
	bus.hookMu.RLock()
	hooks := make([]func({{ $eventType }}, any), len(bus.onPublish))
	copy(hooks, bus.onPublish)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event, payload)
	}
}

func (bus *{{ $busType }}) runOnDrop(event {{ $eventType }}, payload any) {
	bus.hookMu.RLock()
	hooks := make([]func({{ $eventType }}, any), len(bus.onDrop))
	copy(hooks, bus.onDrop)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event, payload)
	}
}

func (bus *{{ $busType }}) runOnSubscribe(event {{ $eventType }}) {
	bus.hookMu.RLock()
	hooks := make([]func({{ $eventType }}), len(bus.onSubscribe))
	copy(hooks, bus.onSubscribe)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event)
	}
}

func (bus *{{ $busType }}) runOnPanic(event {{ $eventType }}, payload any, recovered any) {
	bus.hookMu.RLock()
	hooks := make([]func({{ $eventType }}, any, any), len(bus.onPanic))
	copy(hooks, bus.onPanic)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		func() {
			defer func() { recover() }()
			fn(event, payload, recovered)
		}()
	}
}

// Reference the source variable to suppress unused-variable lint.
var _ = {{ .VarName }}
`
