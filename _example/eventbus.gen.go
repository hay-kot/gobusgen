// Code generated by gobusgen; DO NOT EDIT.
package events

import (
	"context"
	"sync"
)

// Event represents a typed event name.
type Event string

const (
	EventRecipeMutation      Event = "recipe.mutation"
	EventShoppingListCleanup Event = "shopping_list.cleanup"
	EventUserRegistration    Event = "user.registration"
)

// EventBus provides type-safe publish/subscribe for in-process events.
type EventBus struct {
	mu          sync.RWMutex
	subscribers map[Event][]any
	ch          chan envelope

	hookMu      sync.RWMutex
	onPublish   []func(Event, any)
	onDrop      []func(Event, any)
	onSubscribe []func(Event)
	onPanic     []func(Event, any, any)
}

type envelope struct {
	event   Event
	payload any
}

// New creates an EventBus with the given channel buffer size.
func New(size int) *EventBus {
	if size < 1 {
		size = 1
	}

	return &EventBus{
		subscribers: newSubscribersMap(),
		ch:          make(chan envelope, size),
	}
}

func newSubscribersMap() map[Event][]any {
	return map[Event][]any{
		EventRecipeMutation:      {},
		EventShoppingListCleanup: {},
		EventUserRegistration:    {},
	}
}

// Start begins processing events. It blocks until ctx is cancelled.
func (bus *EventBus) Start(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case env := <-bus.ch:
			bus.mu.RLock()
			subs := make([]any, len(bus.subscribers[env.event]))
			copy(subs, bus.subscribers[env.event])
			bus.mu.RUnlock()

			for _, sub := range subs {
				func() {
					defer func() {
						if r := recover(); r != nil {
							bus.runOnPanic(env.event, env.payload, r)
						}
					}()
					if fn, ok := sub.(func(any)); ok {
						fn(env.payload)
					}
				}()
			}
		}
	}
}

// PublishRecipeMutation publishes a recipe.mutation event.
func (bus *EventBus) PublishRecipeMutation(payload MutationEvent) {
	select {
	case bus.ch <- envelope{event: EventRecipeMutation, payload: payload}:
		bus.runOnPublish(EventRecipeMutation, payload)
	default:
		bus.runOnDrop(EventRecipeMutation, payload)
	}
}

// SubscribeRecipeMutation registers a handler for recipe.mutation events.
func (bus *EventBus) SubscribeRecipeMutation(fn func(MutationEvent)) {
	bus.mu.Lock()
	bus.subscribers[EventRecipeMutation] = append(bus.subscribers[EventRecipeMutation], func(v any) {
		payload, ok := v.(MutationEvent)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventRecipeMutation)
}

// PublishShoppingListCleanup publishes a shopping_list.cleanup event.
func (bus *EventBus) PublishShoppingListCleanup(payload ShoppingListCleanup) {
	select {
	case bus.ch <- envelope{event: EventShoppingListCleanup, payload: payload}:
		bus.runOnPublish(EventShoppingListCleanup, payload)
	default:
		bus.runOnDrop(EventShoppingListCleanup, payload)
	}
}

// SubscribeShoppingListCleanup registers a handler for shopping_list.cleanup events.
func (bus *EventBus) SubscribeShoppingListCleanup(fn func(ShoppingListCleanup)) {
	bus.mu.Lock()
	bus.subscribers[EventShoppingListCleanup] = append(bus.subscribers[EventShoppingListCleanup], func(v any) {
		payload, ok := v.(ShoppingListCleanup)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventShoppingListCleanup)
}

// PublishUserRegistration publishes a user.registration event.
func (bus *EventBus) PublishUserRegistration(payload UserRegistrationEvent) {
	select {
	case bus.ch <- envelope{event: EventUserRegistration, payload: payload}:
		bus.runOnPublish(EventUserRegistration, payload)
	default:
		bus.runOnDrop(EventUserRegistration, payload)
	}
}

// SubscribeUserRegistration registers a handler for user.registration events.
func (bus *EventBus) SubscribeUserRegistration(fn func(UserRegistrationEvent)) {
	bus.mu.Lock()
	bus.subscribers[EventUserRegistration] = append(bus.subscribers[EventUserRegistration], func(v any) {
		payload, ok := v.(UserRegistrationEvent)
		if !ok {
			return
		}
		fn(payload)
	})
	bus.mu.Unlock()
	bus.runOnSubscribe(EventUserRegistration)
}

// OnPublish registers a hook that fires after an event is successfully enqueued.
func (bus *EventBus) OnPublish(fn func(Event, any)) {
	bus.hookMu.Lock()
	bus.onPublish = append(bus.onPublish, fn)
	bus.hookMu.Unlock()
}

// OnDrop registers a hook that fires when an event is dropped due to a full buffer.
func (bus *EventBus) OnDrop(fn func(Event, any)) {
	bus.hookMu.Lock()
	bus.onDrop = append(bus.onDrop, fn)
	bus.hookMu.Unlock()
}

// OnSubscribe registers a hook that fires after a subscriber is registered.
func (bus *EventBus) OnSubscribe(fn func(Event)) {
	bus.hookMu.Lock()
	bus.onSubscribe = append(bus.onSubscribe, fn)
	bus.hookMu.Unlock()
}

// OnPanic registers a hook that fires when a subscriber panics.
func (bus *EventBus) OnPanic(fn func(Event, any, any)) {
	bus.hookMu.Lock()
	bus.onPanic = append(bus.onPanic, fn)
	bus.hookMu.Unlock()
}

func (bus *EventBus) runOnPublish(event Event, payload any) {
	bus.hookMu.RLock()
	hooks := make([]func(Event, any), len(bus.onPublish))
	copy(hooks, bus.onPublish)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event, payload)
	}
}

func (bus *EventBus) runOnDrop(event Event, payload any) {
	bus.hookMu.RLock()
	hooks := make([]func(Event, any), len(bus.onDrop))
	copy(hooks, bus.onDrop)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event, payload)
	}
}

func (bus *EventBus) runOnSubscribe(event Event) {
	bus.hookMu.RLock()
	hooks := make([]func(Event), len(bus.onSubscribe))
	copy(hooks, bus.onSubscribe)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		fn(event)
	}
}

func (bus *EventBus) runOnPanic(event Event, payload any, recovered any) {
	bus.hookMu.RLock()
	hooks := make([]func(Event, any, any), len(bus.onPanic))
	copy(hooks, bus.onPanic)
	bus.hookMu.RUnlock()
	for _, fn := range hooks {
		func() {
			defer func() { recover() }()
			fn(event, payload, recovered)
		}()
	}
}

// Reference the source variable to suppress unused-variable lint.
var _ = Events
